<?php
/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

interface THBaseServiceIf
{
    /**
     * Test for the existence of columns in the table, as specified in the TGet.
     * 
     * @return true if the specified TGet matches one or more keys, false if not
     * 
     * @param string $table the table to check on
     * 
     * @param \TGet $tget the TGet to check for
     * 
     * @return bool
     * @throws \TIOError
     */
    public function exists($table, \TGet $tget);
    /**
     * Method for getting data from a row.
     * 
     * If the row cannot be found an empty Result is returned.
     * This can be checked by the empty field of the TResult
     * 
     * @return the result
     * 
     * @param string $table the table to get from
     * 
     * @param \TGet $tget the TGet to fetch
     * 
     * @return \TResult if no Result is found, row and columnValues will not be set.
     * 
     * @throws \TIOError
     */
    public function get($table, \TGet $tget);
    /**
     * Method for getting multiple rows.
     * 
     * If a row cannot be found there will be a null
     * value in the result list for that TGet at the
     * same position.
     * 
     * So the Results are in the same order as the TGets.
     * 
     * @param string $table the table to get from
     * 
     * @param \TGet[] $tgets a list of TGets to fetch, the Result list
     * will have the Results at corresponding positions
     * or null if there was an error
     * 
     * @return \TResult[]
     * @throws \TIOError
     */
    public function getMultiple($table, array $tgets);
    /**
     * Commit a TPut to a table.
     * 
     * @param string $table the table to put data in
     * 
     * @param \TPut $tput the TPut to put
     * 
     * @throws \TIOError
     */
    public function put($table, \TPut $tput);
    /**
     * Atomically checks if a row/family/qualifier value matches the expected
     * value. If it does, it adds the TPut.
     * 
     * @return true if the new put was executed, false otherwise
     * 
     * @param string $table to check in and put to
     * 
     * @param string $row row to check
     * 
     * @param string $family column family to check
     * 
     * @param string $qualifier column qualifier to check
     * 
     * @param string $value the expected value, if not provided the
     * check is for the non-existence of the
     * column in question
     * 
     * @param \TPut $tput the TPut to put if the check succeeds
     * 
     * @return bool
     * @throws \TIOError
     */
    public function checkAndPut($table, $row, $family, $qualifier, $value, \TPut $tput);
    /**
     * Commit a List of Puts to the table.
     * 
     * @param string $table the table to put data in
     * 
     * @param \TPut[] $tputs a list of TPuts to commit
     * 
     * @throws \TIOError
     */
    public function putMultiple($table, array $tputs);
    /**
     * Deletes as specified by the TDelete.
     * 
     * Note: "delete" is a reserved keyword and cannot be used in Thrift
     * thus the inconsistent naming scheme from the other functions.
     * 
     * @param string $table the table to delete from
     * 
     * @param \TDelete $tdelete the TDelete to delete
     * 
     * @throws \TIOError
     */
    public function deleteSingle($table, \TDelete $tdelete);
    /**
     * Bulk commit a List of TDeletes to the table.
     * 
     * Throws a TIOError if any of the deletes fail.
     * 
     * Always returns an empty list for backwards compatibility.
     * 
     * @param string $table the table to delete from
     * 
     * @param \TDelete[] $tdeletes list of TDeletes to delete
     * 
     * @return \TDelete[]
     * @throws \TIOError
     */
    public function deleteMultiple($table, array $tdeletes);
    /**
     * Atomically checks if a row/family/qualifier value matches the expected
     * value. If it does, it adds the delete.
     * 
     * @return true if the new delete was executed, false otherwise
     * 
     * @param string $table to check in and delete from
     * 
     * @param string $row row to check
     * 
     * @param string $family column family to check
     * 
     * @param string $qualifier column qualifier to check
     * 
     * @param string $value the expected value, if not provided the
     * check is for the non-existence of the
     * column in question
     * 
     * @param \TDelete $tdelete the TDelete to execute if the check succeeds
     * 
     * @return bool
     * @throws \TIOError
     */
    public function checkAndDelete($table, $row, $family, $qualifier, $value, \TDelete $tdelete);
    /**
     * @param string $table the table to increment the value on
     * 
     * @param \TIncrement $tincrement the TIncrement to increment
     * 
     * @return \TResult if no Result is found, row and columnValues will not be set.
     * 
     * @throws \TIOError
     */
    public function increment($table, \TIncrement $tincrement);
    /**
     * @param string $table the table to append the value on
     * 
     * @param \TAppend $tappend the TAppend to append
     * 
     * @return \TResult if no Result is found, row and columnValues will not be set.
     * 
     * @throws \TIOError
     */
    public function append($table, \TAppend $tappend);
    /**
     * Get a Scanner for the provided TScan object.
     * 
     * @return Scanner Id to be used with other scanner procedures
     * 
     * @param string $table the table to get the Scanner for
     * 
     * @param \TScan $tscan the scan object to get a Scanner for
     * 
     * @return int
     * @throws \TIOError
     */
    public function openScanner($table, \TScan $tscan);
    /**
     * Grabs multiple rows from a Scanner.
     * 
     * @return Between zero and numRows TResults
     * 
     * @param int $scannerId the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
     * 
     * @param int $numRows number of rows to return
     * 
     * @return \TResult[]
     * @throws \TIOError
     * @throws \TIllegalArgument if the scannerId is invalid
     * 
     */
    public function getScannerRows($scannerId, $numRows);
    /**
     * Closes the scanner. Should be called to free server side resources timely.
     * Typically close once the scanner is not needed anymore, i.e. after looping
     * over it to get all the required rows.
     * 
     * @param int $scannerId the Id of the Scanner to close *
     * 
     * @throws \TIOError
     * @throws \TIllegalArgument if the scannerId is invalid
     * 
     */
    public function closeScanner($scannerId);
    /**
     * mutateRow performs multiple mutations atomically on a single row.
     * 
     * @param string $table table to apply the mutations
     * 
     * @param \TRowMutations $trowMutations mutations to apply
     * 
     * @throws \TIOError
     */
    public function mutateRow($table, \TRowMutations $trowMutations);
    /**
     * Get results for the provided TScan object.
     * This helper function opens a scanner, get the results and close the scanner.
     * 
     * @return between zero and numRows TResults
     * 
     * @param string $table the table to get the Scanner for
     * 
     * @param \TScan $tscan the scan object to get a Scanner for
     * 
     * @param int $numRows number of rows to return
     * 
     * @return \TResult[]
     * @throws \TIOError
     */
    public function getScannerResults($table, \TScan $tscan, $numRows);
}
